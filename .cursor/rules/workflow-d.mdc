# Protocole d'Implémentation de Tâche (Phase D)

### Introduction et Doctrine Fondamentale

**À L'AGENT IA :** Ce document est ton système d'exploitation pour l'implémentation d'une tâche technique. Tu pars d'un plan validé (`task.mdc`). Ta mission est de le transformer en code de production, testé et de haute qualité. Suis ce protocole et ses commandes avec une rigueur absolue.

---
---
**DOCTRINE FONDAMENTALE (À inclure dans tous les workflows)**

1.  **"No Broken Windows" :** Si tu trouves une imperfection dans le code qui est hors du périmètre de ta mission, ne la corrige pas. Dans ton rapport final, signale-la dans une section dédiée `[TECH_DEBT]` pour qu'un humain puisse créer la tâche correspondante.

2.  **"Obedience with Insight" :** Ton rôle n'est pas l'obéissance aveugle. Si une exigence de ta mission te semble ambiguë, techniquement irréalisable ou contradictoire avec un document parent (un `ADR`, le `PRD Global`), ton devoir est de le signaler immédiatement.

3.  **"Prove, then Document" :** Le code n'existe pas sans preuve (tests). La preuve n'a de valeur que si elle est contextualisée par une décision d'architecture documentée (`ADR`) si nécessaire.

4.  **"Principe de la Remontée en Cascade" :** Si tu es bloqué par une ambiguïté dans la spécification, signale que le problème doit être corrigé à la source (ex: dans le `PRD Feature` parent) avant de continuer. Ne fais pas de suppositions.

5.  **"Primacy of the Strategic Plan" :** Le plan stratégique (`_plan.md`) est la source de vérité absolue pour la structure et la séquence du travail. Tu ne dois **JAMAIS** modifier cette structure de ta propre initiative (ne pas créer, supprimer ou modifier une tâche "à la volée"). Si, au cours de ton travail, tu identifies une modification nécessaire (une tâche manquante, une dépendance incorrecte), ton devoir est de **STOPPER** ton processus actuel, de **signaler** la modification requise et de recommander son implémentation. Attends ensuite que l'opérateur humain lance le `Workflow E` (Modification de Plan) pour appliquer formellement le changement.
---
---

### Le Processus d'Implémentation en 7 Phases

#### Phase 1 : Briefing de Mission et Confirmation de l'Approche

**Instruction :** Phase de lecture, de contextualisation et de validation de ta compréhension. Ne génère aucun code d'implémentation ni de commande Git.

1.  **Assimilation du Contexte Stratégique et Spécifique :**
    *   **Analyse de la Tâche Spécifique :** Analyse la tâche assignée (`@task.mdc`). Lis et assimile son objectif, ses `Low-Level Steps`, ses `Acceptance Criteria`, et les fichiers attendus en `END STATE`.
    *   **Analyse du Plan Stratégique :** Localise et lis attentivement le plan stratégique de l'épique correspondante qui a été fournie dans le message de l'utilisateur (ex : `annex/epic-1-iam/_plan.md`). Ce fichier est ta feuille de route globale.

2.  **Vérification de Cohérence (Action Critique) :**
    *   Compare la tâche spécifique (`@task.mdc`) avec le plan stratégique (`_plan.md`). Valide que la tâche s'inscrit logiquement dans le graphe de dépendances global et qu'il n'y a aucune contradiction.

3.  **Confirmation de l'Approche d'Exécution :**
    *   Pour prouver que tu es prêt à passer à l'exécution (Phase 3), rédige un bref **"Résumé d'Exécution"**.
    *   **Important :** Ne recrée pas un plan détaillé. Ton résumé doit simplement confirmer ta compréhension en synthétisant les points suivants à partir du fichier `@task.mdc` :
        *   **Objectif Principal :** Reformule en une phrase l'objectif de la tâche.
        *   **Livrables Clés :** Liste les 2-3 fichiers les plus importants que tu vas créer ou modifier (issus de la section `END STATE`).
        *   **Séquence Principale :** Résume en 2-3 points les étapes majeures que tu vas suivre (issues de la section `Low-Level Steps`).

4.  **Clarification & Challenge :** Ajoute une section "Clarifications & Assumptions".
    *   Si une exigence de la tâche est ambiguë, pose une question pour la clarifier.
    *   **Si tu as détecté une incohérence** à l'étape 2, signale-la immédiatement ici.

**[POINT DE CONTRÔLE HUMAIN N°1 - ASYNCHRONE]**
**STOP.** Soumets ton "Résumé d'Exécution". Attends l'approbation humaine pour passer à la Phase 2.


---

#### Phase 2 : Initialisation de l'Environnement de Travail et Synchronisation

**Instruction :** Une fois le plan approuvé, exécute les commandes suivantes pour préparer et sécuriser la branche de travail.

1.  `git checkout main`
2.  `git pull origin main`
3.  `git checkout -b feature/[ID-du-ticket-description-courte]` (Adapte le nom de la branche comme défini dans le plan).
4.  **`git push -u origin feature/[ID-du-ticket-description-courte]`**
    *   **Note :** Cette commande publie immédiatement la nouvelle branche sur le serveur distant. Cela sécurise le travail et le rend visible pour toute l'équipe et les outils d'intégration continue. L'option `-u` configure le suivi pour que les futurs `git push` et `git pull` fonctionnent sans argument.

---

#### Phase 3 : Développement et Itérations

**Instruction :** Tu es maintenant sur la branche de feature, qui est synchronisée avec le serveur distant. Commence le cycle de développement.

1.  **Cycle TDD :**
    *   Écrire le Test d'Intégration qui échoue (RED).
    *   Écrire le Code d'Implémentation pour faire passer le test (GREEN).
    *   **Contrôle de Conformité Atomique :** Pendant l'écriture du code, respecte scrupuleusement les règles de la directive Atomic Design. **Vérifie que la logique est bien placée au bon niveau** (ex: pas de logique métier dans les atomes/molécules, pas de style de positionnement dans les composants réutilisables).
    *   Refactorer le code pour améliorer sa clarté si nécessaire, en s'assurant que les tests passent toujours.
2.  **Commit et Push Réguliers :** Après chaque avancée significative et fonctionnelle, exécute :
    *   `git add .`
    *   `git commit -m "feat: [décris l'avancée]"` (ou `fix:`, `chore:`, etc.)
    *   **`git push`**
        *   **Note :** La branche étant déjà suivie, un simple `git push` suffit pour synchroniser ton travail.
3.  **Règle d'Escalade :** Après 3 tentatives infructueuses pour faire passer un test, **STOP**. Signale le blocage et demande de l'aide humaine.

---

#### Phase 4 : Validation Automatisée (Quality Gate)

**Instruction :** Prouve que ton travail est sûr en exécutant le script de Quality Gate. Ce script est configuré pour échouer et arrêter tout le processus (`set -e`/`$ErrorActionPreference = "Stop"`) si une seule étape de validation n'est pas respectée.

**Phase 4A – Diagnostic (analyse partagée avec l'humain)**
1.  Détecte ton OS :
    *   macOS / Linux : `QUALITY_GATE_DIAG=1 npm run quality-gate:mac`
    *   Windows : `powershell -NoProfile -Command "$Env:QUALITY_GATE_DIAG='1'; npm run quality-gate:win"`
2.  Exécute la commande diagnostic depuis la racine. Pour chaque étape (`lint`, `typecheck`, `test`, `build`) :
    *   consigne toute sortie en la classant en **erreur** ou **warning** ;
    *   évalue la gravité :
        - `critical` : erreurs ou warnings contenant “warning”, “warn”, “unsafe”, “deprecated”, ou annonçant une rupture proche (“will stop working in the next major version”, etc.) ;
        - `minor` : warnings informatifs non bloquants.
    *   en mode diagnostic, aucune correction n'est appliquée automatiquement ; le script se termine toujours avec succès.
3.  Partage le rapport markdown généré (`reports/quality-gate/<ID_TACHE>-quality-gate-report.md`) et les journaux bruts avec l'opérateur humain. Identifie clairement les entrées marquées `Action = fix` (erreurs + warnings `critical`) et celles en `Action = keep` (`minor`). Attends les instructions sur les corrections à effectuer.

**Phase 4B – Enforcement (corrections et validation finale)**
4.  Sur instruction humaine, repasse en mode enforcement :
    *   macOS / Linux : `npm run quality-gate:mac`
    *   Windows : `npm run quality-gate:win`
5.  Corrige **toutes les entrées `Action = fix`** (erreurs et warnings `critical`) puis relance la commande jusqu’à obtenir un run où :
    *   aucune erreur n’est présente ;
    *   aucun warning `critical` ne subsiste ;
    *   seuls des warnings `minor` éventuels restent consignés.
    Conserve tous les journaux (runs échoués et run final propre).
6.  Après le run propre, mets à jour le rapport markdown (même nom de fichier) avec les statuts `corrigé` / `non corrigé`, et joins-le en Phase 5.

**Note :** Assure-toi que ton terminal permet l'exécution des scripts et exporte les journaux complets (stdout/stderr) de chaque run ; range-les avec le rapport dans `reports/quality-gate/`.

---

#### Phase 5 : Handoff pour Validation Humaine

**Instruction :** Prépare le compte-rendu pour la revue humaine.

1.  Rédige l'ADR, le PIP et la liste de `[TECH_DEBT]` si nécessaire.
2.  Prépare un message de synthèse final.

**[POINT DE CONTRÔLE HUMAIN N°2 - VALIDATION POUR FUSION]**
**Action :** Affiche le bloc de texte suivant et attends l'instruction de l'opérateur.

> ---
> **Instructions pour l'Opérateur Humain :**
>
> 1.  **Revue du Code :** Le travail a été réalisé et prouvé sur la branche `feature/[nom-de-la-branche]`. Veuillez la vérifier.
> 2.  **Validation Finale :** Effectuez vos propres tests si nécessaire.
> 3.  **Instruction de Fusion :** Si le travail est approuvé, répondez par : **"Le travail est validé. Procède à la fusion dans main."**
>
> ---

---

#### Phase 6 : Fusion Contrôlée (sur instruction humaine)

**Instruction :** N'exécute cette phase que sur réception de la commande de fusion explicite.

1.  Accuse réception de l'ordre.
2.  Exécute rigoureusement les commandes suivantes :
    *   `git checkout main`
    *   `git pull origin main`
    *   `git merge feature/[nom-de-la-branche]`
3.  **Gestion des Conflits :**
    *   **En cas de succès :** Passe à l'étape 4.
    *   **En cas de conflit :** **STOP IMMEDIATEMENT.** Annule la fusion (`git merge --abort`). Signale le conflit. Ne tente jamais de le résoudre.
4.  **Finalisation :**
    *   `git push origin main`
5.  Informe l'opérateur que la fusion et le push ont réussi, puis passe à la phase finale.

---

#### Phase 7 : Nettoyage (sur instruction humaine)

**Instruction :** Le code est sur `main`. Propose de nettoyer l'environnement de travail.

1.  Pose la question : "La fusion est terminée. Puis-je supprimer la branche `feature/[nom-de-la-branche]` en local et sur le dépôt distant ?"
2.  **Si la réponse est "oui"**, exécute :
    *   `git branch -d feature/[nom-de-la-branche]`
    *   `git push origin --delete feature/[nom-de-la-branche]`
3.  Confirme que le nettoyage est terminé. La tâche est maintenant officiellement close.
